{"meta":{"title":"Bomblebee","subtitle":"","description":"","author":"Huang Feng","url":"http://dangkei.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-01T06:15:40.117Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"http://dangkei.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-07-01T06:15:40.121Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"http://dangkei.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-01T08:52:42.262Z","updated":"2021-07-01T08:52:42.262Z","comments":false,"path":"about/index.html","permalink":"http://dangkei.github.io/about/index.html","excerpt":"","text":"2021-07-01 建党100周年纪念日看到一个好的主题pure，感觉非常不错就换了，非常感谢这个主题的作者，虽然更新后很多内容都没有了，不过还好有备份。 有时间慢慢恢复吧。自己已经是一个大龄程序员了， 走过很长一段人生路， 对生命，生活，亲情，爱情，家庭都有了一些新的认知。 希望今后的道路上让编程重新成为自己的爱好而不止是谋生的手段，重拾自己对技术的兴趣。 也希望自己身边的人都健康，快乐。"},{"title":"友情链接","date":"2021-07-01T06:15:40.124Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"http://dangkei.github.io/links/index.html","excerpt":"","text":""},{"title":"项目库","date":"2021-07-01T07:53:18.384Z","updated":"2021-07-01T07:53:18.384Z","comments":false,"path":"repository/index.html","permalink":"http://dangkei.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-05T07:35:42.586Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"categories/index.html","permalink":"http://dangkei.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-01T06:15:40.204Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"http://dangkei.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-07-05T08:32:38.116Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"http://dangkei.github.io/404.html","excerpt":"","text":""}],"posts":[{"title":"Java_double_brace_initialization","slug":"Java-double-brace-initialization","date":"2021-07-06T10:30:00.000Z","updated":"2021-07-06T10:30:51.446Z","comments":true,"path":"2021/07/06/Java-double-brace-initialization/","link":"","permalink":"http://dangkei.github.io/2021/07/06/Java-double-brace-initialization/","excerpt":"","text":"Java Double Brace Initialization 1. 创建和初始化不带双大括号的对象您不觉得Java应该为集合（List、Map、Set等）提供更方便的语法吗。我之所以这么说，是因为每次如果我们必须在代码中使用集合，那么我们就必须执行以下操作- 为临时集合声明变量 创建一个新的空集合，并在变量中存储对它的引用 把东西收藏起来 将集合传递给方法 例如：WithoutDoubleBrace.java 123456789101112131415161718192021&gt;import java.util.HashSet;&gt;import java.util.Set;&gt;public class WithoutDoubleBrace &gt;&#123; public static void main(String[] args) &gt;&#123; Set&lt;String&gt; params = new HashSet&lt;String&gt;(); params.add(&quot;param one&quot;); params.add(&quot;param two&quot;); params.add(&quot;param three&quot;); params.add(&quot;param four&quot;); // ... and so on; Now pass above collection as parameter to method or // some other ways useParamsInSomeMethod(params); &#125; private static void useParamsInSomeMethod(Set&lt;String&gt; params) &#123; // TODO Auto-generated method stub &#125;&gt;&#125; 这些都是我们在实时编码实践中遵循的正常步骤。 2. 在“单步”中创建和初始化对象的双大括号初始化让我们看看另一种简单的方法。这就是所谓的双大括号初始化。使用双大括号功能的语法如下： DoubleBrace.java 12345678910111213141516171819202122232425&gt;import java.util.HashSet;&gt;import java.util.Set;&gt;public class DoubleBrace &gt;&#123; public static void main(String[] args) &#123; Set&lt;String&gt; params = new HashSet&lt;String&gt;() &#123; &#123; add(&quot;param one&quot;); add(&quot;param two&quot;); add(&quot;param three&quot;); add(&quot;param four&quot;); &#125; &#125;; // ... and so on; Now pass above collection as parameter to method or // some other ways useParamsInSomeMethod(params); &#125; private static void useParamsInSomeMethod(Set&lt;String&gt; params) &#123; // TODO Auto-generated method stub &#125;&gt;&#125; 2.1. 内联双大括号初始化或者更简单一些： 12345678910111213141516171819&gt;import java.util.HashSet;&gt;public class DoubleBrace &#123; public static void main(String[] args) &#123; useParamsInSomeMethod(new HashSet&lt;String&gt;() &#123; &#123; add(&quot;param one&quot;); add(&quot;param two&quot;); add(&quot;param three&quot;); add(&quot;param four&quot;); &#125; &#125;); &#125; private static void useParamsInSomeMethod(HashSet&lt;String&gt; params) &#123; //perform some operation &#125;&gt;&#125; 3. 双大括号初始化如何工作？让我们了解这是如何工作的。第一个大括号创建一个新的匿名内部类。这些内部类能够访问其父类的行为。所以，在我们的例子中，我们实际上是在创建HashSet类的子类，所以这个内部类能够使用add（）方法。 第二组大括号只不过是实例初始值设定项。如果您提醒核心java概念，那么您可以很容易地将实例初始值设定项块与静态初始值设定项相关联，因为类似于大括号的结构。唯一的区别是，静态初始值设定项是用static关键字添加的，并且只运行一次；不管您创建了多少个对象。 4. 摘要 因为用双括号初始化的类基本上是内部类。所以我们可以为所有其他类创建它们，直到它们不是最终的。 如果没有显式修改equals（）方法以使用这些类，则不应使用此类类，因为equals（）方法通常也会检查类的相等性。 您应该始终记住，初始值设定项是在构造函数之前运行的（而不是在超类构造函数之前）。 您创建的匿名类的实例包含对封闭对象的合成引用。如果序列化集合，还将序列化外部类中的所有内容。 5. Java 9 工厂方法Java 9带来了很多工厂方法，可以用来创建和初始化单个语句中的Java集合。如果您使用Java 9或更高版本，它可以是一种替代方法，也是首选方法。它消除了双支撑初始化的必要性。 12345678&gt;List&lt;String&gt; names = List.of(&quot;lokesh&quot;, &quot;rohit&quot;, &quot;alex&quot;);&gt;Set&lt;String&gt; names = Set.of(&quot;Lokesh&quot;, &quot;Amit&quot;, &quot;John&quot;);&gt;Map&lt;String, String&gt; names = Map.ofEntries( Map.entry(&quot;1&quot;, &quot;Lokesh&quot;), Map.entry(&quot;2&quot;, &quot;Amit&quot;), Map.entry(&quot;3&quot;, &quot;Brian&quot;)); 6. Java 8 流收集器对于Java 8和更低版本，您可以在Java流的形式中找到类似的用例。 12&gt;Set&lt;String&gt; names = Stream.of(&quot;lokesh&quot;, &quot;rohit&quot;, &quot;alex&quot;) .collect( collectingAndThen( toSet(), Collections::unmodifiableSet ) );","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/tags/java/"}]},{"title":"Java的标准IO与新IO有什么区别","slug":"java-standard-IO-vs-new-IO","date":"2021-07-05T07:42:37.000Z","updated":"2021-07-05T08:23:06.396Z","comments":true,"path":"2021/07/05/java-standard-IO-vs-new-IO/","link":"","permalink":"http://dangkei.github.io/2021/07/05/java-standard-IO-vs-new-IO/","excerpt":"","text":"jdk1.4引入了Java新的输入/输出（NIO）。在标准IO离开的地方，NIO向Java库提供了高速、面向块的IO。 通过定义类来保存数据，并通过在块中处理这些数据，NIO利用了低级优化的优势，其方式是java.io文件如果不使用本机代码，包就无法。 在本文中，我们将重点确定标准IO与新IO之间最显著的区别，在决定下一个项目中使用哪一个IO之前，我们必须知道这些差异。 召回标准IO JavaIO是指计算机与世界其他地区之间，或是单个程序与计算机其余部分之间的接口。 在Java编程中，IO类直到最近才使用流隐喻来实现。所有IO都被视为单个字节的移动，一次一个，通过一个名为流的对象。 流IO用于与外界接触。它也用于内部，用于将对象转换为字节，然后返回对象。它被称为序列化和反序列化。 引入Java新IO JavaNIO的创建是为了允许Java程序员实现高速输入输出操作，而不必编写自定义的本机代码。 NIO将最耗时的I/O活动（即填充和排空缓冲区）移回操作系统，从而使速度大大提高。 如果以上介绍让你口渴，那么不要担心你会不会在我们前进的时候感觉好一些。我们先找出不同点。 学习NIO的先决条件 javai/O如何在底层内部工作？ 这篇博文主要讨论与I/O相关的事情是如何在较低级别上工作的。这篇文章的读者想知道javai/O操作是如何在机器级别映射的，以及应用程序运行时硬件一直在做什么。我假设您熟悉基本的IO操作，例如读取文件、通过javai/oapi编写文件；因为这超出了本文的范围。 标准IO和NIO之间的差异 在本教程中，我将重点介绍在决定在下一个项目中使用哪一个之前必须知道的最显著的差异。","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"}]},{"title":"Java IO内部是如何工作的?","slug":"how-java-io-work","date":"2021-07-01T08:17:34.000Z","updated":"2021-07-06T07:27:12.478Z","comments":true,"path":"2021/07/01/how-java-io-work/","link":"","permalink":"http://dangkei.github.io/2021/07/01/how-java-io-work/","excerpt":"","text":"本文旨在为那些好奇知道如何在机器级别映射Java IO操作以及在应用程序运行时硬件始终做什么的读者编写。 我假设您熟悉基本的IO操作，例如读取文件、通过JavaIO API编写文件；因为这超出了本文的范围。 缓冲区处理和内核与用户空间“input/output”一词只意味着将数据移出缓冲区。 缓冲区以及缓冲区的处理方式是所有IO的基础。你只要时刻记住这个。 通常，进程通过请求操作系统从缓冲区（写入操作）中排出数据或用数据填充缓冲区（读取操作）来执行IO。这是IO概念的全部总结。 操作系统中执行这些传输的机器可能非常复杂，但从概念上讲，它非常简单，我们将在本文中讨论其中的一小部分。 os级的数据缓冲 上图显示了块数据如何从外部源（例如硬盘）移动到正在运行的进程（例如RAM）内的内存区域的简化“逻辑”图。 首先，进程请求通过调用read（）系统来填充其缓冲区。 读调用导致内核向磁盘控制器硬件发出命令，以从磁盘中获取数据。 磁盘控制器通过DMA直接将数据写入内核内存缓冲区，而不需要主CPU的进一步帮助。 磁盘控制器完成缓冲区填充后，内核将数据从内核空间中的临时缓冲区复制到进程指定的缓冲区；当请求read（）操作时。 需要注意的一点是内核试图缓存和/或预取数据，因此进程请求的数据可能已经在内核空间中可用。如果是，则将复制流程请求的数据。 如果数据不可用，则进程将暂停，而内核则将数据带入内存。 虚拟内存 您一定已经多次听说过虚拟内存。让我想想。 所有现代操作系统都利用虚拟内存。虚拟内存是指人工地址或虚拟地址被用来代替物理（硬件RAM）内存地址。 虚拟内存带来两个重要优势： 多个虚拟地址可以引用相同的物理内存位置。 虚拟内存空间可以大于实际可用硬件内存。 在前面的部分中，从内核空间复制到最终用户缓冲区似乎是额外的工作。为什么不告诉磁盘控制器直接发送到userspace中的缓冲区？好吧，它是用虚拟内存完成的，这是上面的优势1。 通过将内核空间地址映射到与用户空间中的虚拟地址相同的物理地址，DMA硬件（只能访问物理内存地址）可以填充内核和用户空间进程同时可见的缓冲区。 这消除了内核和用户空间之间的拷贝，但需要内核和用户缓冲区共享相同的页面对齐方式。缓冲区还必须是磁盘控制器使用的块大小的倍数（通常是512字节磁盘扇区）。 操作系统将内存地址空间划分为页，页是固定大小的字节组。这些内存页总是磁盘块大小的倍数，通常是2的幂（这简化了寻址）。典型的内存页大小是1024、2048和4096字节。 虚拟内存页和物理内存页的大小总是相同的。 内存分页 为了支持虚拟内存的第二个优点（可寻址空间大于物理内存），有必要进行虚拟内存分页（通常称为交换）。 内存分页是一种方案，通过这种方案，虚拟内存空间的页面可以持久化到外部磁盘存储器中，以便在物理内存中为其他虚拟页面腾出空间。从本质上讲，物理内存充当分页区域的缓存，分页区域是磁盘上的空间，当物理内存被挤出时，存储内存页的内容。 将内存页大小调整为磁盘块大小的倍数允许内核向磁盘控制器硬件发出直接命令，将内存页写入磁盘或在需要时重新加载它们。 原来，所有磁盘IO都是在页面级别完成的。在现代的分页操作系统中，这是数据在磁盘和物理内存之间移动的唯一方式。 现代CPU包含一个子系统，称为内存管理单元（MMU）。这个设备在逻辑上位于CPU和物理内存之间。MMU包含将虚拟地址转换为物理内存地址所需的映射信息。 当CPU引用内存位置时，MMU确定该位置所在的页（通常通过移动或屏蔽地址值的位）并将该虚拟页号转换为物理页号（这在硬件中完成，并且非常快）。 面向文件/块的IO 文件IO总是发生在文件系统的上下文中。文件系统与磁盘截然不同。磁盘将数据存储在扇区中，每个扇区通常为512字节。它们是对文件的语义一无所知的硬件设备。它们只是提供了一些可以存储数据的插槽。在这方面，磁盘的扇区类似于内存页；所有扇区的大小都是一致的，并且可以作为一个大数组寻址。 另一方面，文件系统是更高层次的抽象。文件系统是一种特殊的方法，用于排列和解释存储在磁盘（或其他一些随机存取、面向块的设备）上的数据。您编写的代码几乎总是与文件系统交互，而不是直接与磁盘交互。文件系统定义了文件名、路径、文件、文件属性等的抽象。 文件系统（在硬盘中）组织一系列大小一致的数据块。一些块存储元信息，如空闲块、目录、索引等的映射。其他块包含实际的文件数据。 有关单个文件的元信息描述了哪些块包含文件数据、数据结束的位置、上次更新的时间等。 当用户进程请求读取文件数据时，文件系统实现会准确地确定数据在磁盘上的位置。然后它采取措施将这些磁盘扇区放入内存。 文件系统也有页的概念，页的大小可以是基本内存页的大小，也可以是基本内存页的倍数。典型的文件系统页面大小从2048字节到8192字节不等，并且总是基本内存页面大小的倍数。 分页文件系统如何执行IO归结为以下逻辑步骤： 确定请求跨越的文件系统页（磁盘扇区组）。磁盘上的文件内容和/或元数据可能分布在多个文件系统页面上，这些页面可能是不连续的。 在内核空间中分配足够的内存页以容纳已标识的文件系统页。 在这些内存页和磁盘上的文件系统页之间建立映射。 为每个内存页生成页错误。 虚拟内存系统捕获页面错误并调度pagein（即分页空间pagein），通过从磁盘读取页面内容来验证这些页面。 一旦pagein完成，文件系统就会分解原始数据以提取请求的文件内容或属性信息。 注意，这个文件系统数据将像其他内存页一样被缓存。在随后的IO请求中，部分或全部文件数据可能仍存在于物理内存中，并且可以重用，而无需从磁盘重新读取 文件锁定 文件锁定是一种方案，通过该方案，一个进程可以阻止其他进程访问某个文件或限制其他进程访问该文件的方式。虽然“文件锁定”这个名称意味着锁定整个文件（通常是这样做的），但锁定通常在更细粒度的级别上可用。 文件区域通常是锁定的，粒度降低到字节级别。锁与特定文件相关联，从该文件中的特定字节位置开始，并在特定的字节范围内运行。这一点很重要，因为它允许许多进程协调对文件特定区域的访问，而不会妨碍文件中其他进程的工作。 文件锁有两种类型：共享锁和独占锁。多个共享锁可能同时对同一文件区域有效。另一方面，独占锁要求没有其他锁对请求的区域有效。 流IO 并非所有IO都是面向块的。还有流IO，它是基于管道建模的。必须按顺序访问IO流的字节。TTY（控制台）设备、打印机端口和网络连接是流的常见示例。 流通常（但不一定）比块设备慢，并且通常是间歇输入的源。大多数操作系统允许将流置于非阻塞模式，这允许进程检查流上的输入是否可用，如果此时没有可用的输入，则不会卡住。这样的功能允许进程在输入到达时处理输入，但在输入流空闲时执行其他功能。 超越非阻塞模式的一个步骤是能够进行就绪选择。这类似于非阻塞模式（并且通常构建在非阻塞模式之上），但是减轻了对流是否准备好用于操作系统的检查。 可以告诉操作系统监视流的集合，并向进程返回指示哪些流已就绪。这种能力允许进程利用操作系统返回的就绪信息，使用公共代码和单个线程多路复用多个活动流。 流IO在网络服务器中被广泛用于处理大量的网络连接。准备就绪选择对于高容量扩展至关重要。 这些都是关于这个有大量技术词汇的非常复杂的话题🙂","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"}]},{"title":"静态导入声明的一些重要规则","slug":"import-rules","date":"2021-07-01T07:59:18.000Z","updated":"2021-07-06T08:08:07.770Z","comments":true,"path":"2021/07/01/import-rules/","link":"","permalink":"http://dangkei.github.io/2021/07/01/import-rules/","excerpt":"","text":"import static静态导入是JDK1.5中的新特性。一般我们导入一个类都用 import com…..ClassName;而静态导入是这样：import static com…..ClassName.;这里的多了个static，还有就是类名ClassName后面多了个 . ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名 的方式来调用。这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…);就可以将其写入一个静态方法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便 下面是关于静态导入声明的一些重要规则。 1） 如果导入两个具有相同简单名称的静态成员，一个使用单个静态导入声明，另一个使用静态按需导入声明，则使用单个静态导入声明导入的静态成员优先。 假设有两个类，package1.Class1和package2.Class2。两个类都有一个名为methodA的静态方法。以下代码将使用package1.Class1.methodA（）方法，因为它是使用单个静态导入声明导入的： 12345678&gt;import static package1.Class1.methodA; // Imports Class1.methodA() method&gt;import static package2.Class2.*; // Imports Class2.methodA() method too &gt;public class Test &#123; public static void main(String[] args) &#123; methodA(); // Class1.methodA() will be called &#125;&gt;&#125; 2） 不允许使用单个静态导入声明导入两个具有相同简单名称的静态成员。以下静态导入声明生成错误，因为它们都使用相同的简单名称methodA导入静态成员： 12&gt;import static package1.Class1.methodA;&gt;import static package1.Class2.methodA; // An error 3） 如果使用单个静态导入声明导入静态成员，并且同一类中存在同名的静态成员，则该类中的静态成员将被使用。 123456789101112131415161718192021222324252627&gt;// A.java&gt;package package1; &gt;public class A &#123; public static void test() &#123; System.out.println(&quot;package1.A.test()&quot;); &#125;&gt;&#125; &gt;// Test.java&gt;package package2; &gt;import static package1.A.test; &gt;public class Test &#123; public static void main(String[] args) &#123; test(); // Will use package2.Test.test() method, not package1.A.test() method &#125; public static void test() &#123; System.out.println(&quot;package2.Test.test()&quot;); &#125;&gt;&#125;&gt;Output:&gt;package2.Test.test() 静态导入似乎可以帮助您使用静态成员的简单名称，从而使程序更易于编写和读取。有时静态导入可能会在程序中引入细微的错误，这可能很难调试。建议您完全不要使用静态导入，或者仅在非常罕见的情况下使用。","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"static","slug":"static","permalink":"http://dangkei.github.io/tags/static/"},{"name":"import","slug":"import","permalink":"http://dangkei.github.io/tags/import/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-01T06:15:22.557Z","updated":"2021-07-06T07:35:01.611Z","comments":true,"path":"2021/07/01/hello-world/","link":"","permalink":"http://dangkei.github.io/2021/07/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server123$ hexo server //or$ hexo s More info: Server Generate static files123$ hexo generate//or$ hexo g More info: Generating Deploy to remote sites123$ hexo deploy//or$ hexo d More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://dangkei.github.io/categories/hexo/"}],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"},{"name":"hexo","slug":"hexo","permalink":"http://dangkei.github.io/categories/hexo/"}],"tags":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/tags/java/"},{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"},{"name":"static","slug":"static","permalink":"http://dangkei.github.io/tags/static/"},{"name":"import","slug":"import","permalink":"http://dangkei.github.io/tags/import/"}]}